// These are the interfaces for all the states in this game
import { IBaseGame, IBaseGameObject, IBasePlayer } from "@cadre/ts-utils/cadre";

// This is a file generated by the Creer, it may have empty interfaces,
// but we need them, so let's disable that tslint rule
// tslint:disable:no-empty-interface

/**
 * Collect slime and cover the battlefield with dropped blobs to win.
 */
export interface IGameState extends IBaseGame {
    /**
     * Blobs of size > 1 can move this many tiles per turn.
     */
    bigBlobSpeed: number;

    /**
     * How much slime it costs to spawn a blob.
     */
    blobCost: number;

    /**
     * Every blob costs its owner this amount of slime every turn.
     */
    blobUpkeep: number;

    /**
     * Every Blobmaster in the game.
     */
    blobmasters: IBlobState[];

    /**
     * Every Blob in the game.
     */
    blobs: IBlobState[];

    /**
     * The player with fewer blobs is given this much slime per less blobs every
     * turn.
     */
    bonusSlimeForFewerBlobs: number;

    /**
     * The player whose turn it is currently. That player can send commands.
     * Other players cannot.
     */
    currentPlayer: IPlayerState;

    /**
     * The current turn number, starting at 0 for the first player's turn.
     */
    currentTurn: number;

    /**
     * The amount of slime added to a blob or wall's tiles when it dies.
     */
    deathSlime: number;

    /**
     * A mapping of every game object's ID to the actual game object. Primarily
     * used by the server and client to easily refer to the game objects via ID.
     */
    gameObjects: {[id: string]: IGameObjectState};

    /**
     * The amount of slime given back to a blob's owner when it turns into a
     * wall.
     */
    hardenReward: number;

    /**
     * The number of turns it takes a blob to harden into a wall.
     */
    hardenTime: number;

    /**
     * The number of Tiles in the map along the y (vertical) axis.
     */
    mapHeight: number;

    /**
     * The number of Tiles in the map along the x (horizontal) axis.
     */
    mapWidth: number;

    /**
     * A Blobmaster can drop at most this many blobs per turn.
     */
    maxDropsPerTurn: number;

    /**
     * The maximum amount of slime a player can hold at any one time.
     */
    maxPlayerSlime: number;

    /**
     * No more slime will spawn on a tile with at least this much slime already
     * on it.
     */
    maxSlimeSpawnedOnTile: number;

    /**
     * The maximum number of walls spawned at the start of the match.
     */
    maxStartingWalls: number;

    /**
     * The maximum number of turns before the game will automatically end.
     */
    maxTurns: number;

    /**
     * The minimum number of walls spawned at the start of the match.
     */
    minStartingWalls: number;

    /**
     * It takes the ceiling of this many turns times the number tiles away from
     * your blobmaster to drop a blob onto a tile.
     */
    perTileDropDelay: number;

    /**
     * List of all the players in the game.
     */
    players: IPlayerState[];

    /**
     * A player wins if they can reach this many cumulative tiles covered.
     */
    pointsToWin: number;

    /**
     * A unique identifier for the game instance that is being played.
     */
    session: string;

    /**
     * This much slime is added to every empty tile every turn.
     */
    slimeSpawnRate: number;

    /**
     * 1x1 blobs can move this many tiles per turn.
     */
    smallBlobSpeed: number;

    /**
     * All the tiles in the map, stored in Row-major order. Use `x + y *
     * mapWidth` to access the correct index.
     */
    tiles: ITileState[];

    /**
     * A player wins if they can cover this many tiles with their blobs on a
     * single turn.
     */
    tilesCoveredToWin: number;

    /**
     * The amount of time (in nano-seconds) added after each player performs a
     * turn.
     */
    timeAddedPerTurn: number;

    /**
     * The number of turns a hardened blob wall lasts.
     */
    wallLifespan: number;

}

/**
 * A Blob.  Can move and collect slime.
 */
export interface IBlobState extends IGameObjectState {
    /**
     * How many more Blobs this Blobmaster can spawn this turn.
     */
    dropsLeft: number;

    /**
     * If this Blob is a Blobmaster.
     */
    isBlobmaster: boolean;

    /**
     * If this Blob is dead and has been removed from the game.
     */
    isDead: boolean;

    /**
     * How many more moves this Blob can do this turn.
     */
    movesLeft: number;

    /**
     * The Player that owns and can control this Blob, or null if this is a
     * wall.
     */
    owner: IPlayerState;

    /**
     * The width and height of this Blob.
     */
    size: number;

    /**
     * The top-left (smallest x,y) Tile that this Blob occupies.
     */
    tile: ITileState;

    /**
     * How many more turns till this wall disappears, or negative.
     */
    turnsTillDead: number;

    /**
     * How many more turns till this blob becomes a wall, or negative.
     */
    turnsTillHardened: number;

}

/**
 * An object in the game. The most basic class that all game classes should
 * inherit from automatically.
 */
export interface IGameObjectState extends IBaseGameObject {
    /**
     * String representing the top level Class that this game object is an
     * instance of. Used for reflection to create new instances on clients, but
     * exposed for convenience should AIs want this data.
     */
    gameObjectName: string;

    /**
     * A unique id for each instance of a GameObject or a sub class. Used for
     * client and server communication. Should never change value after being
     * set.
     */
    id: string;

    /**
     * Any strings logged will be stored here. Intended for debugging.
     */
    logs: string[];

}

/**
 * A player in this game. Every AI controls one player.
 */
export interface IPlayerState extends IGameObjectState, IBasePlayer {
    /**
     * The Blobmaster owned by this Player.
     */
    blobmaster: IBlobState;

    /**
     * Every Blob owned by this Player.
     */
    blobs: IBlobState[];

    /**
     * What type of client this is, e.g. 'Python', 'JavaScript', or some other
     * language. For potential data mining purposes.
     */
    clientType: string;

    /**
     * Tiles which future blobs will drop onto, this determines the order in
     * which simultaneous drops are handled.
     */
    drops: ITileState[];

    /**
     * If the player lost the game or not.
     */
    lost: boolean;

    /**
     * The name of the player.
     */
    name: string;

    /**
     * This player's opponent in the game.
     */
    opponent: IPlayerState;

    /**
     * The reason why the player lost the game.
     */
    reasonLost: string;

    /**
     * The reason why the player won the game.
     */
    reasonWon: string;

    /**
     * How many points this player has.
     */
    score: number;

    /**
     * How much slime this player has.
     */
    slime: number;

    /**
     * The amount of time (in ns) remaining for this AI to send commands.
     */
    timeRemaining: number;

    /**
     * If the player won the game or not.
     */
    won: boolean;

}

/**
 * A Tile in the game that makes up the 2D map grid.
 */
export interface ITileState extends IGameObjectState {
    /**
     * The Blob that is on this Tile, null otherwise.
     */
    blob: IBlobState;

    /**
     * The owner of the blob dropping onto this tile, or null.
     */
    dropOwner: IPlayerState;

    /**
     * Turns until a blob is dropped onto this tile. negative if no blob is in
     * transit to this tile.
     */
    dropTurnsLeft: number;

    /**
     * How much slime exists on this Tile.
     */
    slime: number;

    /**
     * The Tile to the 'East' of this one (x+1, y). Null if out of bounds of the
     * map.
     */
    tileEast: ITileState;

    /**
     * The Tile to the 'North' of this one (x, y-1). Null if out of bounds of
     * the map.
     */
    tileNorth: ITileState;

    /**
     * The Tile to the 'South' of this one (x, y+1). Null if out of bounds of
     * the map.
     */
    tileSouth: ITileState;

    /**
     * The Tile to the 'West' of this one (x-1, y). Null if out of bounds of the
     * map.
     */
    tileWest: ITileState;

    /**
     * The x (horizontal) position of this Tile.
     */
    x: number;

    /**
     * The y (vertical) position of this Tile.
     */
    y: number;

}
